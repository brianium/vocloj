["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$vocloj.state","~:imports",null,"~:requires",["^ ","~$vocloj.state.impl","^9"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$->AtomStateMachine","^9"],"~:defs",["^ ","~$create-atom-state-machine",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/brian/projects/vocloj/src/cljc/vocloj/state.cljc","~:line",5,"~:column",7,"~:end-line",5,"~:end-column",32,"~:arglists",["~#list",["~$quote",["^G",[["~$states","~$initial-state"],["^I","^J","~$atom-fn"]]]]],"~:doc","Create a vocloj state machine backed by atoms.\n   \n   This function can be called with three arguments to specify the function\n   used for creating the atom. This is useful for atom like types such as reagent's\n   ratoms:\n   \n   ```clojure\n   (create-atom-state-machine states default reagent.core/atom)\n   ```\n   \n   The states map should be a hash map indicated supported states and their\n   allowed transitions. A transition key is a named event and the transition\n   value is the expected state after said event occurs:\n   \n   ```clojure\n   {:speaking {:pause :paused}\n    :paused   {:resume :speaking}}\n   ```\n   \n   The above state map indicates that only when the state machine is in a speaking state,\n   can a pause event be used via core.transition to move the machine to a paused state. Similarly,\n   only a paused machine can be resumed to a speaking state via a resume event.\n   \n   The initial-state must be a map that will be used as the initial value of the underlying\n   atom map's :data value.\n   \n   If an atom-fn is given, it will be called with the initial state provided\n   to this function. This may be useful for something like using reagent's \"ratoms\" instead of\n   Clojure's own atoms.","~:top-fn",["^ ","~:variadic?",false,"~:fixed-arity",3,"~:max-fixed-arity",3,"~:method-params",[["^I","^J"],["^I","^J","^K"]],"^F",["^G",[["^I","^J"],["^I","^J","^K"]]],"~:arglists-meta",["^G",[null,null]]]],"^5","~$vocloj.state/create-atom-state-machine","^A","src/cljc/vocloj/state.cljc","^E",32,"^M",["^ ","^N",false,"^O",3,"^P",3,"^Q",[["^I","^J"],["^I","^J","^K"]],"^F",["^G",[["^I","^J"],["^I","^J","^K"]]],"^R",["^G",[null,null]]],"^Q",[["^I","^J"],["^I","^J","^K"]],"~:protocol-impl",null,"^O",3,"^R",["^G",[null,null]],"^C",1,"^N",false,"~:methods",[["^ ","^O",2,"^N",false,"~:tag","~$any"],["^ ","^O",3,"^N",false,"^V","~$vocloj.state.impl/AtomStateMachine"]],"^B",5,"^D",5,"^P",3,"~:fn-var",true,"^F",["^G",[["^I","^J"],["^I","^J","^K"]]],"^L","Create a vocloj state machine backed by atoms.\n   \n   This function can be called with three arguments to specify the function\n   used for creating the atom. This is useful for atom like types such as reagent's\n   ratoms:\n   \n   ```clojure\n   (create-atom-state-machine states default reagent.core/atom)\n   ```\n   \n   The states map should be a hash map indicated supported states and their\n   allowed transitions. A transition key is a named event and the transition\n   value is the expected state after said event occurs:\n   \n   ```clojure\n   {:speaking {:pause :paused}\n    :paused   {:resume :speaking}}\n   ```\n   \n   The above state map indicates that only when the state machine is in a speaking state,\n   can a pause event be used via core.transition to move the machine to a paused state. Similarly,\n   only a paused machine can be resumed to a speaking state via a resume event.\n   \n   The initial-state must be a map that will be used as the initial value of the underlying\n   atom map's :data value.\n   \n   If an atom-fn is given, it will be called with the initial state provided\n   to this function. This may be useful for something like using reagent's \"ratoms\" instead of\n   Clojure's own atoms."],"~$create-recognizer-state-machine",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/projects/vocloj/src/cljc/vocloj/state.cljc","^B",40,"^C",7,"^D",40,"^E",38,"^F",["^G",["^H",["^G",[["^K"],[]]]]],"^L","This is merely a suggestion for recognizer state machines.\n   \n   The atom-fn functions per create-atom-state-machine.\n\n   The underlying state machine supports the following states:\n   \n   ```clojure\n   {:dormant   {:init :ready}\n    :ready     {:start :listening}\n    :listening {:stop :dormant}} \n   ```\n   \n   The initial state reflects a dormant recognizer with nil data in state. A dormant\n   recognizer will do nothing until it is initialized then started.","^M",["^ ","^N",false,"^O",1,"^P",1,"^Q",[["^K"],[]],"^F",["^G",[["^K"],[]]],"^R",["^G",[null,null]]]],"^5","~$vocloj.state/create-recognizer-state-machine","^A","src/cljc/vocloj/state.cljc","^E",38,"^M",["^ ","^N",false,"^O",1,"^P",1,"^Q",[["^K"],[]],"^F",["^G",[["^K"],[]]],"^R",["^G",[null,null]]],"^Q",[["^K"],[]],"^T",null,"^O",1,"^R",["^G",[null,null]],"^C",1,"^N",false,"^U",[["^ ","^O",1,"^N",false,"^V","^X"],["^ ","^O",0,"^N",false,"^V","^X"]],"^B",40,"^D",40,"^P",1,"^Y",true,"^F",["^G",[["^K"],[]]],"^L","This is merely a suggestion for recognizer state machines.\n   \n   The atom-fn functions per create-atom-state-machine.\n\n   The underlying state machine supports the following states:\n   \n   ```clojure\n   {:dormant   {:init :ready}\n    :ready     {:start :listening}\n    :listening {:stop :dormant}} \n   ```\n   \n   The initial state reflects a dormant recognizer with nil data in state. A dormant\n   recognizer will do nothing until it is initialized then started."],"~$create-synthesis-state-machine",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/projects/vocloj/src/cljc/vocloj/state.cljc","^B",66,"^C",7,"^D",66,"^E",37,"^F",["^G",["^H",["^G",[["^K"],[]]]]],"^L","This is merely a suggestion for synthesizer state machines.\n   \n   The atom-fn functions per create-atom-state-machine.\n   \n   The underlying state machine supports the following states:\n   \n   ```clojure\n   {:dormant     {:init  :ready}\n    :ready       {:change-voices :ready\n                  :speak         :speaking}\n    :speaking    {:pause :paused\n                  :end   :ready}\n    :paused      {:resume :speaking}}\n   ```\n   \n   The initial state reflects a dormant synthesizer with nil data in state. A dormant\n   synthesizer will do nothing until it is initialized.","^M",["^ ","^N",false,"^O",1,"^P",1,"^Q",[["^K"],[]],"^F",["^G",[["^K"],[]]],"^R",["^G",[null,null]]]],"^5","~$vocloj.state/create-synthesis-state-machine","^A","src/cljc/vocloj/state.cljc","^E",37,"^M",["^ ","^N",false,"^O",1,"^P",1,"^Q",[["^K"],[]],"^F",["^G",[["^K"],[]]],"^R",["^G",[null,null]]],"^Q",[["^K"],[]],"^T",null,"^O",1,"^R",["^G",[null,null]],"^C",1,"^N",false,"^U",[["^ ","^O",1,"^N",false,"^V","^X"],["^ ","^O",0,"^N",false,"^V","^X"]],"^B",66,"^D",66,"^P",1,"^Y",true,"^F",["^G",[["^K"],[]]],"^L","This is merely a suggestion for synthesizer state machines.\n   \n   The atom-fn functions per create-atom-state-machine.\n   \n   The underlying state machine supports the following states:\n   \n   ```clojure\n   {:dormant     {:init  :ready}\n    :ready       {:change-voices :ready\n                  :speak         :speaking}\n    :speaking    {:pause :paused\n                  :end   :ready}\n    :paused      {:resume :speaking}}\n   ```\n   \n   The initial state reflects a dormant synthesizer with nil data in state. A dormant\n   synthesizer will do nothing until it is initialized."]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:paused","~:ready","~:init","~:speaking","~:dormant","~:start","~:state","~:stop","~:listening","~:pause","~:change-voices","~:end","~:speak","~:resume","~:data"]],"~:order",["^1:","^17","^1>","^18","^1;","^1=","^1<","^1D","^19","^16","^1@","^1B","^1?","^1A","^1C"]],"^L","Contains default states for vocloj state machines"]