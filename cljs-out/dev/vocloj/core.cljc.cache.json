["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$vocloj.core","~:imports",null,"~:requires",["^ ","~$impl","~$vocloj.core.impl","^:","^:"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$speak",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/brian/projects/vocloj/src/cljc/vocloj/core.cljc","~:line",173,"~:column",7,"~:end-line",173,"~:end-column",12,"~:arglists",["~#list",["~$quote",["^G",[["~$synth","~$voice-id","~$utterance"]]]]],"~:doc","Enqueue an utterance for speech with the given\n   synthesizer.\n   \n   The voice-id is a unique identifier specific to the synthesizer\n   implementation. For example, synthesizer implementation in vocloj.web might use\n   a URI of the form \"Alex\".\n   \n   The utterance is a hash map, but it's structure may vary depending on the implementation.\n   All synthesizers should minimally support a :text key with a string value indicating the speech\n   to utter.\n   \n   ```clojure\n   (speak synthesizer \"Alex\" {:text \"Hello from the speakers!\"})\n   ```"],"^5","~$vocloj.core/speak","^A","src/cljc/vocloj/core.cljc","^E",12,"~:method-params",["^G",[["^I","^J","^K"]]],"~:protocol-impl",null,"~:arglists-meta",["^G",[null,null]],"^C",1,"~:variadic?",false,"^B",173,"~:ret-tag","~$any","^D",173,"~:max-fixed-arity",3,"~:fn-var",true,"^F",["^G",["^H",["^G",[["^I","^J","^K"]]]]],"^L","Enqueue an utterance for speech with the given\n   synthesizer.\n   \n   The voice-id is a unique identifier specific to the synthesizer\n   implementation. For example, synthesizer implementation in vocloj.web might use\n   a URI of the form \"Alex\".\n   \n   The utterance is a hash map, but it's structure may vary depending on the implementation.\n   All synthesizers should minimally support a :text key with a string value indicating the speech\n   to utter.\n   \n   ```clojure\n   (speak synthesizer \"Alex\" {:text \"Hello from the speakers!\"})\n   ```"],"~$resume",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/projects/vocloj/src/cljc/vocloj/core.cljc","^B",166,"^C",7,"^D",166,"^E",13,"^F",["^G",["^H",["^G",[["^I"]]]]],"^L","Resume a paused synthesizer.\n   \n   Returns the value given."],"^5","~$vocloj.core/resume","^A","src/cljc/vocloj/core.cljc","^E",13,"^N",["^G",[["^I"]]],"^O",null,"^P",["^G",[null,null]],"^C",1,"^Q",false,"^B",166,"^R","^S","^D",166,"^T",1,"^U",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^L","Resume a paused synthesizer.\n   \n   Returns the value given."],"~$current-state",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/projects/vocloj/src/cljc/vocloj/core.cljc","^B",66,"^C",7,"^D",66,"^E",20,"^F",["^G",["^H",["^G",[["~$sm"]]]]],"^L","Returns the in-transaction-value of the state machine's underlying\n   ref.\n   \n   This can be useful if the given implementation stores state that may be useful\n   to a user. For instance the speech synthesizer implementation in vocloj.web provides\n   access to support voices:\n   \n   ```clojure\n   (-> synth current-state :data :voices)\n   ```"],"^5","~$vocloj.core/current-state","^A","src/cljc/vocloj/core.cljc","^E",20,"^N",["^G",[["^Y"]]],"^O",null,"^P",["^G",[null,null]],"^C",1,"^Q",false,"^B",66,"^R","^S","^D",66,"^T",1,"^U",true,"^F",["^G",["^H",["^G",[["^Y"]]]]],"^L","Returns the in-transaction-value of the state machine's underlying\n   ref.\n   \n   This can be useful if the given implementation stores state that may be useful\n   to a user. For instance the speech synthesizer implementation in vocloj.web provides\n   access to support voices:\n   \n   ```clojure\n   (-> synth current-state :data :voices)\n   ```"],"~$init",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/projects/vocloj/src/cljc/vocloj/core.cljc","^B",80,"^C",7,"^D",80,"^E",11,"^F",["^G",["^H",["^G",[["~$initializable"]]]]],"^L","Initializes something worthy of initialization.\n   \n   Speech synthesizers and speech recognizers implement the Initializable protocol\n   in order to setup necessary resources or kick off requests for necessary data.\n\n   This function is useful when explicit lifecycle management is desired - for something\n   like a reloaded workflow.\n   \n   Functions like listen may call this before returning a channel.\n\n   Returns the value given."],"^5","~$vocloj.core/init","^A","src/cljc/vocloj/core.cljc","^E",11,"^N",["^G",[["^10"]]],"^O",null,"^P",["^G",[null,null]],"^C",1,"^Q",false,"^B",80,"^R","^S","^D",80,"^T",1,"^U",true,"^F",["^G",["^H",["^G",[["^10"]]]]],"^L","Initializes something worthy of initialization.\n   \n   Speech synthesizers and speech recognizers implement the Initializable protocol\n   in order to setup necessary resources or kick off requests for necessary data.\n\n   This function is useful when explicit lifecycle management is desired - for something\n   like a reloaded workflow.\n   \n   Functions like listen may call this before returning a channel.\n\n   Returns the value given."],"~$transition",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/projects/vocloj/src/cljc/vocloj/core.cljc","^B",36,"^C",7,"^D",36,"^E",17,"^F",["^G",["^H",["^G",[["^Y","~$event","~$payload"],["^Y","^13"]]]]],"^L","Transition a state machine using the given event and an optional payload.\n   \n   transition is mostly used within vocloj implementations, but may be useful\n   in other circumstances. I don't know. I can't predict the future one bit.\n   \n   The payload can be a hash map or a function that returns a hash map. If a function, the\n   payload must be a function of 1 arg: the state machine itself.\n   \n   The payload hash map will replace the state machine's internal state entirely. A function\n   payload may be useful for merging state instead of replacing it entirely.\n   \n   ```clojure\n   ;;; Set state to the given data\n   (core/transition this :init {:recognition          recognition\n                                :speech-ch            speech-ch\n                                :listener/result      on-result})\n   \n   ;;; Maintain current state\n   (core/transition this :pause current-data)\n\n   ;;; Set the current state to nil by omitting the payload altogether\n   (core/transition this :stop)\n   ```","~:top-fn",["^ ","^Q",false,"~:fixed-arity",3,"^T",3,"^N",[["^Y","^13","^14"],["^Y","^13"]],"^F",["^G",[["^Y","^13","^14"],["^Y","^13"]]],"^P",["^G",[null,null]]]],"^5","~$vocloj.core/transition","^A","src/cljc/vocloj/core.cljc","^E",17,"^15",["^ ","^Q",false,"^16",3,"^T",3,"^N",[["^Y","^13","^14"],["^Y","^13"]],"^F",["^G",[["^Y","^13","^14"],["^Y","^13"]]],"^P",["^G",[null,null]]],"^N",[["^Y","^13","^14"],["^Y","^13"]],"^O",null,"^16",3,"^P",["^G",[null,null]],"^C",1,"^Q",false,"~:methods",[["^ ","^16",3,"^Q",false],["^ ","^16",2,"^Q",false,"~:tag","^S"]],"^B",36,"^D",36,"^T",3,"^U",true,"^F",["^G",[["^Y","^13","^14"],["^Y","^13"]]],"^L","Transition a state machine using the given event and an optional payload.\n   \n   transition is mostly used within vocloj implementations, but may be useful\n   in other circumstances. I don't know. I can't predict the future one bit.\n   \n   The payload can be a hash map or a function that returns a hash map. If a function, the\n   payload must be a function of 1 arg: the state machine itself.\n   \n   The payload hash map will replace the state machine's internal state entirely. A function\n   payload may be useful for merging state instead of replacing it entirely.\n   \n   ```clojure\n   ;;; Set state to the given data\n   (core/transition this :init {:recognition          recognition\n                                :speech-ch            speech-ch\n                                :listener/result      on-result})\n   \n   ;;; Maintain current state\n   (core/transition this :pause current-data)\n\n   ;;; Set the current state to nil by omitting the payload altogether\n   (core/transition this :stop)\n   ```"],"~$start",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/projects/vocloj/src/cljc/vocloj/core.cljc","^B",95,"^C",7,"^D",95,"^E",12,"^F",["^G",["^H",["^G",[["~$recognizer"]]]]],"^L","Actually begin listening for speech on the given recognizer.\n   \n   Returns the value given."],"^5","~$vocloj.core/start","^A","src/cljc/vocloj/core.cljc","^E",12,"^N",["^G",[["^1;"]]],"^O",null,"^P",["^G",[null,null]],"^C",1,"^Q",false,"^B",95,"^R","^S","^D",95,"^T",1,"^U",true,"^F",["^G",["^H",["^G",[["^1;"]]]]],"^L","Actually begin listening for speech on the given recognizer.\n   \n   Returns the value given."],"~$add-effect",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/projects/vocloj/src/cljc/vocloj/core.cljc","^B",6,"^C",7,"^D",6,"^E",17,"^F",["^G",["^H",["^G",[["^Y","~$key","~$fn-3"],["^Y","^1>","~$from","~$to","^1?"]]]]],"^L","Register a function to be called in response to a state change.\n   \n   The given key should be unique for the given state machine.\n\n   The effect fn must be an fn of 3 args: the state machine, the old state, and the new state.\n   \n   When add-effect is invoked with three arguments, the effect fn will be called\n   when any state change occurs:\n   \n   ```clojure\n   (add-effect my-synthesizer ::fun (fn [synth old-state new-state]\n                                      (do-something-fun synth old-state new-state)))\n   ```\n   \n   When add-effect is called with five arguments, the effect fn will be called when\n   an explicit state transition occurs:\n   \n   ```clojure\n   (add-effect my-synthesizer ::resumed :paused :speaking on-resume)\n   ```\n   \n   The add-effect function is useful for monitoring state changes or dispatching\n   other effects in response to state changes.","^15",["^ ","^Q",false,"^16",5,"^T",5,"^N",[["^Y","^1>","^1?"],["^Y","^1>","^1@","^1A","^1?"]],"^F",["^G",[["^Y","^1>","^1?"],["^Y","^1>","^1@","^1A","^1?"]]],"^P",["^G",[null,null]]]],"^5","~$vocloj.core/add-effect","^A","src/cljc/vocloj/core.cljc","^E",17,"^15",["^ ","^Q",false,"^16",5,"^T",5,"^N",[["^Y","^1>","^1?"],["^Y","^1>","^1@","^1A","^1?"]],"^F",["^G",[["^Y","^1>","^1?"],["^Y","^1>","^1@","^1A","^1?"]]],"^P",["^G",[null,null]]],"^N",[["^Y","^1>","^1?"],["^Y","^1>","^1@","^1A","^1?"]],"^O",null,"^16",5,"^P",["^G",[null,null]],"^C",1,"^Q",false,"^18",[["^ ","^16",3,"^Q",false],["^ ","^16",5,"^Q",false,"^19","^S"]],"^B",6,"^D",6,"^T",5,"^U",true,"^F",["^G",[["^Y","^1>","^1?"],["^Y","^1>","^1@","^1A","^1?"]]],"^L","Register a function to be called in response to a state change.\n   \n   The given key should be unique for the given state machine.\n\n   The effect fn must be an fn of 3 args: the state machine, the old state, and the new state.\n   \n   When add-effect is invoked with three arguments, the effect fn will be called\n   when any state change occurs:\n   \n   ```clojure\n   (add-effect my-synthesizer ::fun (fn [synth old-state new-state]\n                                      (do-something-fun synth old-state new-state)))\n   ```\n   \n   When add-effect is called with five arguments, the effect fn will be called when\n   an explicit state transition occurs:\n   \n   ```clojure\n   (add-effect my-synthesizer ::resumed :paused :speaking on-resume)\n   ```\n   \n   The add-effect function is useful for monitoring state changes or dispatching\n   other effects in response to state changes."],"~$stop",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/projects/vocloj/src/cljc/vocloj/core.cljc","^B",102,"^C",7,"^D",102,"^E",11,"^F",["^G",["^H",["^G",[["^1;"]]]]],"^L","Makes the given recognizer stop listening for speech.\n   \n   Returns the value given."],"^5","~$vocloj.core/stop","^A","src/cljc/vocloj/core.cljc","^E",11,"^N",["^G",[["^1;"]]],"^O",null,"^P",["^G",[null,null]],"^C",1,"^Q",false,"^B",102,"^R","^S","^D",102,"^T",1,"^U",true,"^F",["^G",["^H",["^G",[["^1;"]]]]],"^L","Makes the given recognizer stop listening for speech.\n   \n   Returns the value given."],"~$listen",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/projects/vocloj/src/cljc/vocloj/core.cljc","^B",109,"^C",7,"^D",109,"^E",13,"^F",["^G",["^H",["^G",[["^1;"],["^1;","~$handler"]]]]],"^L","Probably the preferred means for using a speech recognizer.\n  \n   This function serves as a shortcut for initializing then starting the\n   given recognizer.\n   \n   When called with one argument, listen returns a core.async channel that will receive\n   transcript results.\n   \n   The following snippet shows the implementation of listen's two argument\n   alternative. Different stop logic can be used that calls (stop recognizer) explicitly.\n\n   ```clojure\n   (let [ch      (listen recognizer)\n         stop-ch (-> recognizer current-state :data :stop-ch)]\n     (async/go-loop []\n       (let [[v p] (async/alts! [ch stop-ch])]\n         (when (= p ch)\n           (handler v)\n           (recur))))\n     recognizer)\n   ```\n   \n   When called with two arguments, the second argument must be an fn\n   of one argument: the result of detecting speech.\n   \n   ```clojure\n   (listen recognizer (fn [result] (do-something-with-result result)))\n   ```\n   \n   The results put on the channel will always be lists of hash-maps containing\n   minimally :transcript and :confidence keys:\n   \n   ```clojure\n   ({:transcript \"Hello from my microphone!\" :confidence 0.999}) \n   ```","^15",["^ ","^Q",false,"^16",2,"^T",2,"^N",[["^1;"],["^1;","^1F"]],"^F",["^G",[["^1;"],["^1;","^1F"]]],"^P",["^G",[null,null]]]],"^5","~$vocloj.core/listen","^A","src/cljc/vocloj/core.cljc","^E",13,"^15",["^ ","^Q",false,"^16",2,"^T",2,"^N",[["^1;"],["^1;","^1F"]],"^F",["^G",[["^1;"],["^1;","^1F"]]],"^P",["^G",[null,null]]],"^N",[["^1;"],["^1;","^1F"]],"^O",null,"^16",2,"^P",["^G",[null,null]],"^C",1,"^Q",false,"^18",[["^ ","^16",1,"^Q",false,"^19","^S"],["^ ","^16",2,"^Q",false,"^19","^S"]],"^B",109,"^D",109,"^T",2,"^U",true,"^F",["^G",[["^1;"],["^1;","^1F"]]],"^L","Probably the preferred means for using a speech recognizer.\n  \n   This function serves as a shortcut for initializing then starting the\n   given recognizer.\n   \n   When called with one argument, listen returns a core.async channel that will receive\n   transcript results.\n   \n   The following snippet shows the implementation of listen's two argument\n   alternative. Different stop logic can be used that calls (stop recognizer) explicitly.\n\n   ```clojure\n   (let [ch      (listen recognizer)\n         stop-ch (-> recognizer current-state :data :stop-ch)]\n     (async/go-loop []\n       (let [[v p] (async/alts! [ch stop-ch])]\n         (when (= p ch)\n           (handler v)\n           (recur))))\n     recognizer)\n   ```\n   \n   When called with two arguments, the second argument must be an fn\n   of one argument: the result of detecting speech.\n   \n   ```clojure\n   (listen recognizer (fn [result] (do-something-with-result result)))\n   ```\n   \n   The results put on the channel will always be lists of hash-maps containing\n   minimally :transcript and :confidence keys:\n   \n   ```clojure\n   ({:transcript \"Hello from my microphone!\" :confidence 0.999}) \n   ```"],"~$pause",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/projects/vocloj/src/cljc/vocloj/core.cljc","^B",159,"^C",7,"^D",159,"^E",12,"^F",["^G",["^H",["^G",[["^I"]]]]],"^L","Pauses speech currently being uttered. Can be resumed with the resume function.\n   \n   Returns the value given."],"^5","~$vocloj.core/pause","^A","src/cljc/vocloj/core.cljc","^E",12,"^N",["^G",[["^I"]]],"^O",null,"^P",["^G",[null,null]],"^C",1,"^Q",false,"^B",159,"^R","^S","^D",159,"^T",1,"^U",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^L","Pauses speech currently being uttered. Can be resumed with the resume function.\n   \n   Returns the value given."],"~$cancel",["^ ","^?",null,"^@",["^ ","^A","/Users/brian/projects/vocloj/src/cljc/vocloj/core.cljc","^B",150,"^C",7,"^D",150,"^E",13,"^F",["^G",["^H",["^G",[["^I"]]]]],"^L","Cancel speech synthesis occurring on the given synthesizer. This\n   may mean different things to different implementations, but generally\n   this means removing all enqueued utterances and stopping all speech.\n   \n   Returns the given value."],"^5","~$vocloj.core/cancel","^A","src/cljc/vocloj/core.cljc","^E",13,"^N",["^G",[["^I"]]],"^O",null,"^P",["^G",[null,null]],"^C",1,"^Q",false,"^B",150,"^R","^S","^D",150,"^T",1,"^U",true,"^F",["^G",["^H",["^G",[["^I"]]]]],"^L","Cancel speech synthesis occurring on the given synthesizer. This\n   may mean different things to different implementations, but generally\n   this means removing all enqueued utterances and stopping all speech.\n   \n   Returns the given value."]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"^L","vocloj provides a Clojure(Script) api for doing things with speech - i.e text to speech,\n   and speech to text."]